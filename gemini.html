<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>楚汉骄兵 - Crossover Chess (V4)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            background-color: #e8e8e8;
            padding-top: 20px;
        }
        #game-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            align-items: center;
        }
        #board-container {
            position: relative;
            width: 540px; /* 9 columns * 60px */
            height: 600px; /* 10 rows * 60px */
            background-color: #f1d3a9;
            border: 2px solid #6b4b3a;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        #info-panel {
            width: 220px;
            padding: 20px;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #info-panel h2 {
            margin-top: 0;
            text-align: center;
            color: #333;
        }
        #info-panel p {
            font-size: 1.1em;
            color: #555;
        }
        #current-turn {
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 4px;
        }
        #current-turn.red {
            color: #c00;
            background-color: #fee;
        }
        #current-turn.black {
            color: #000;
            background-color: #ddd;
        }
        #game-status {
            font-weight: bold;
            color: #007bff;
        }
        #reset-button {
            display: block;
            width: 100%;
            padding: 10px;
            font-size: 1em;
            color: #fff;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        #reset-button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="board-container">
        <canvas id="board-canvas" width="540" height="600"></canvas>
        <canvas id="pieces-canvas" width="540" height="600"></canvas>
    </div>
    <div id="info-panel">
        <h2>游戏信息</h2>
        <p>当前回合: <span id="current-turn"></span></p>
        <p>游戏状态: <span id="game-status"></span></p>
        <button id="reset-button">重新开始</button>
        
    </div>
</div>

<script>
    // --- 1. 初始化和常量 ---
    const boardCanvas = document.getElementById('board-canvas');
    const piecesCanvas = document.getElementById('pieces-canvas');
    const boardCtx = boardCanvas.getContext('2d');
    const piecesCtx = piecesCanvas.getContext('2d');

    const COLS = 9;
    const ROWS = 9; // 总行数修正为 9
    const SQUARE_SIZE = 60;
    const PIECE_RADIUS = SQUARE_SIZE / 2 - 5;
    const PADDING = 30; 
    
    // --- 新增常用于区域划分的常量 ---
    const RIVER_Y_MIN = 3;
    const RED_PALACE_Y_MIN = 6; // 红方九宫从 y=6 开始 (即 y=6, 7, 8)
    const BOARD_WIDTH = (COLS - 1) * SQUARE_SIZE + 2 * PADDING; // 540
    const BOARD_HEIGHT = (ROWS - 1) * SQUARE_SIZE + 2 * PADDING; // 540
    
    // **音效替换区：使用 Base64 Data URI**
    // **音效替换区：使用 Web Audio API (纯代码合成)**

    // 创建一个全局 AudioContext 
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    /**
     * 播放一个合成音效
     * @param {number} freq 频率 (Hz)
     * @param {number} duration 持续时间 (秒)
     * @param {number} gain 音量 (0.0 to 1.0)
     */
    function playSynthSound(freq, duration, gain) {
        if (!audioCtx) return;

        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        oscillator.type = 'sine'; // 正弦波
        oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime);

        // ADSR 封装 (简单渐入渐出)
        gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
        gainNode.gain.linearRampToValueAtTime(gain, audioCtx.currentTime + 0.01); // 快速渐入
        gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration); // 渐出

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        oscillator.start();
        oscillator.stop(audioCtx.currentTime + duration);
    }

    // 移动音效：短促的低音
    const moveSound = { play: () => playSynthSound(440, 0.1, 0.5) };

    // 吃子音效：短促的高音 (表示“击中”)
    const captureSound = { play: () => playSynthSound(660, 0.15, 0.7) };
    
    let boardState = [];
    let currentPlayer = 'black';
    let selectedPiece = null;
    let validMoves = [];
    let gameStatus = 'ongoing';
        // --- 状态追踪变量（新增） ---
    let hasKingMoved = { 'black': false, 'red': false }; // 只需要追踪黑王（b_k）
    let hasRookMoved = {
        'b_r_long': false, // 后翼车（x=0, y=0）
        'b_r_short': false, // 王翼车（x=7, y=0）
        // 红车无需追踪
    };

    const PIECES = {
        'r_g': { name: '帅', color: 'red' }, 'r_a': { name: '仕', color: 'red' },
        'r_e': { name: '相', color: 'red' }, 'r_h': { name: '馬', color: 'red' },
        'r_r': { name: '車', color: 'red' }, 'r_c': { name: '炮', color: 'red' },
        'r_p': { name: '兵', color: 'red' },
        'b_k': { name: '♚', color: 'black', isWestern: true },
        'b_q': { name: '♛', color: 'black', isWestern: true },
        'b_r': { name: '♜', color: 'black', isWestern: true },
        'b_b': { name: '♝', color: 'black', isWestern: true },
        'b_n': { name: '♞', color: 'black', isWestern: true },
        'b_p': { name: '♟', color: 'black', isWestern: true },
    };

    // --- 2. 绘制 ---
    function drawBoard() {
        // 修正 Canvas 尺寸
        boardCanvas.width = BOARD_WIDTH;
        boardCanvas.height = BOARD_HEIGHT;
        piecesCanvas.width = BOARD_WIDTH;
        piecesCanvas.height = BOARD_HEIGHT;

        boardCtx.clearRect(0, 0, BOARD_WIDTH, BOARD_HEIGHT);
        boardCtx.strokeStyle = '#6b4b3a';
        boardCtx.lineWidth = 1;
        
        // 绘制棋盘网格 (9列 x 9行)
        for (let i = 0; i < COLS; i++) {
            boardCtx.beginPath();
            boardCtx.moveTo(PADDING + i * SQUARE_SIZE, PADDING);
            boardCtx.lineTo(PADDING + i * SQUARE_SIZE, PADDING + (ROWS - 1) * SQUARE_SIZE);
            boardCtx.stroke();
        }
        for (let j = 0; j < ROWS; j++) {
            boardCtx.beginPath();
            boardCtx.moveTo(PADDING, PADDING + j * SQUARE_SIZE);
            boardCtx.lineTo(PADDING + (COLS - 1) * SQUARE_SIZE, PADDING + j * SQUARE_SIZE);
            boardCtx.stroke();
        }
        
        // 绘制楚河汉界（y=3 和 y=4 之间的 1 行空间）
        const riverY = PADDING + RIVER_Y_MIN * SQUARE_SIZE; // 河界从 y=3 的线开始
        boardCtx.clearRect(PADDING, riverY + 1, (COLS - 1) * SQUARE_SIZE, 1 * SQUARE_SIZE - 2); // 清除 y=3 和 y=4 之间的区域
        
        boardCtx.font = '24px KaiTi, STKaiti';
        boardCtx.fillStyle = '#6b4b3a';
        boardCtx.textAlign = 'center';
        boardCtx.textBaseline = 'middle';
        boardCtx.fillText('楚 河', PADDING + 2 * SQUARE_SIZE, riverY + SQUARE_SIZE/2);
        boardCtx.fillText('汉 界', PADDING + 6 * SQUARE_SIZE, riverY + SQUARE_SIZE/2);

        // 绘制红方九宫 (y=6 到 y=8, 3行)
        const redPalace = [[RED_PALACE_Y_MIN, 3]]; // [y, x] of top-left corner
        redPalace.forEach(([y, x]) => {
            boardCtx.beginPath();
            boardCtx.moveTo(PADDING + x * SQUARE_SIZE, PADDING + y * SQUARE_SIZE);
            boardCtx.lineTo(PADDING + (x + 2) * SQUARE_SIZE, PADDING + (y + 2) * SQUARE_SIZE);
            boardCtx.moveTo(PADDING + (x + 2) * SQUARE_SIZE, PADDING + y * SQUARE_SIZE);
            boardCtx.lineTo(PADDING + x * SQUARE_SIZE, PADDING + (y + 2) * SQUARE_SIZE);
            boardCtx.stroke();
        });
        
        // 绘制黑方禁区 (x=8 列)，现在仅覆盖黑方自由移动区 (y=0 到 y=2)
        const banAreaHeight = (RIVER_Y_MIN-0.5) * SQUARE_SIZE; // y=0, 1, 2
        
        boardCtx.strokeStyle = 'red';
        boardCtx.lineWidth = 3;
        boardCtx.beginPath();
        // 绘制左侧边界线（从 0 行到 2 行底部）
        boardCtx.moveTo(PADDING + 8 * SQUARE_SIZE - 2, PADDING);
        boardCtx.lineTo(PADDING + 8 * SQUARE_SIZE - 2, PADDING + banAreaHeight);
        boardCtx.stroke();
        
        // 绘制顶部边界线
        boardCtx.beginPath();
        boardCtx.moveTo(PADDING + 8 * SQUARE_SIZE - 2, PADDING);
        boardCtx.lineTo(PADDING + 9 * SQUARE_SIZE, PADDING);
        boardCtx.stroke();
        
        // 绘制填充区域
        boardCtx.fillStyle = 'rgba(255, 0, 0, 0.1)';
        boardCtx.fillRect(PADDING + 8 * SQUARE_SIZE, PADDING, SQUARE_SIZE, banAreaHeight);
    }
    
    function drawPiecesAndHighlights() {
        piecesCtx.clearRect(0, 0, piecesCanvas.width, piecesCanvas.height);
        
        // 绘制合法走法高亮
        if (selectedPiece && validMoves.length > 0) {
            validMoves.forEach(move => {
                const targetPiece = getPiece(move.x, move.y);
                const isTargetEmpty = targetPiece === null;
                
                const cx = PADDING + move.x * SQUARE_SIZE;
                const cy = PADDING + move.y * SQUARE_SIZE;

                // --- 绘制填充圆 ---
                piecesCtx.beginPath(); // 确保从新的路径开始，避免影响后续边框绘制
                piecesCtx.arc(cx, cy, isTargetEmpty ? PIECE_RADIUS / 2 : PIECE_RADIUS, 0, 2 * Math.PI);
                piecesCtx.fillStyle = isTargetEmpty ? 'rgba(34, 139, 34, 0.5)' : 'rgba(255, 69, 0, 0.5)';
                piecesCtx.fill();
                
                // --- 吃子高亮优化: 加粗红色边框 ---
                if (!isTargetEmpty) {
                    piecesCtx.beginPath(); // 确保边框也是独立路径
                    piecesCtx.arc(cx, cy, PIECE_RADIUS, 0, 2 * Math.PI);
                    piecesCtx.strokeStyle = 'red';
                    piecesCtx.lineWidth = 10; 
                    piecesCtx.stroke();
                }
            });
        }
        
        // 绘制棋子
        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                if (boardState[y][x]) {
                    const pieceId = boardState[y][x];
                    const piece = PIECES[pieceId];
                    const cx = PADDING + x * SQUARE_SIZE;
                    const cy = PADDING + y * SQUARE_SIZE;

                    piecesCtx.beginPath();
                    piecesCtx.arc(cx, cy, PIECE_RADIUS, 0, 2 * Math.PI);
                    
                    if (selectedPiece && selectedPiece.x === x && selectedPiece.y === y) {
                        piecesCtx.fillStyle = '#ffcc00'; // 选中高亮
                    } else {
                        piecesCtx.fillStyle = '#fff0d9';
                    }
                    piecesCtx.fill();
                    piecesCtx.strokeStyle = piece.color === 'red' ? '#c00' : '#000';
                    piecesCtx.lineWidth = 2;
                    piecesCtx.stroke();

                    piecesCtx.fillStyle = piece.color === 'red' ? '#c00' : '#000';
                    piecesCtx.textAlign = 'center';
                    piecesCtx.textBaseline = 'middle';
                    if (piece.isWestern) {
                        piecesCtx.font = '32px Arial';
                    } else {
                        piecesCtx.font = 'bold 26px KaiTi, STKaiti';
                    }
                    piecesCtx.fillText(piece.name, cx, cy);
                }
            }
        }
    }

    // --- 3. 游戏逻辑 ---
    
    // ## 辅助函数 ##
    const isOnBoard = (x, y) => x >= 0 && x < COLS && y >= 0 && y < ROWS;
    const getPiece = (x, y) => isOnBoard(x,y) ? boardState[y][x] : null;
    const getColor = (x, y) => {
        const pieceId = getPiece(x,y);
        return pieceId ? PIECES[pieceId].color : null;
    }
    const isOpponent = (x, y, ownColor) => getColor(x,y) !== null && getColor(x,y) !== ownColor;
    const isEmpty = (x, y) => getPiece(x, y) === null;
    
    // 检查目标点是否可移动/吃子 (新增黑方禁区检查)
    // 检查目标点是否可移动/吃子 (修正黑方禁区逻辑)
    const canMoveTo = (x, y, ownColor) => {
    if (!isOnBoard(x, y)) return false;
    
    if (x === COLS - 1) { // 检查禁区 (最右列 x=8)

        const isTargetRowInBlackArea = y <= 2; // 黑方半场和河 (y=0 到 y=2)
        

        if (isTargetRowInBlackArea) {
            return false;
        }
  
    }

    return isEmpty(x, y) || isOpponent(x, y, ownColor);
}
    
    // 红方帅 (r_g) 的移动逻辑
    function getGeneralMoves(x, y, color) {
        let moves = [];
        const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        const palace = { xMin: 3, xMax: 5, yMin: 7, yMax: 9 };

        // 1. 九宫内的常规移动
        directions.forEach(([dx, dy]) => {
            const newX = x + dx, newY = y + dy;
            if (newX >= palace.xMin && newX <= palace.xMax && newY >= palace.yMin && newY <= palace.yMax) {
                if (canMoveTo(newX, newY, color)) {
                    moves.push({ x: newX, y: newY });
                }
            }
        });

        // 2. 王见王（飞将） - 允许红王飞过去吃黑王
        const opponentKingId = 'b_k';
        let oppKingPos = null;

        // 搜索黑王的位置
        for (let i = 0; i < ROWS; i++) {
            for (let j = 0; j < COLS; j++) {
                if (boardState[i][j] === opponentKingId) {
                    oppKingPos = {x: j, y: i};
                    break;
                }
            }
            if (oppKingPos) break;
        }
        
        // 检查是否在同一直线（垂直），且中间无子
        if (oppKingPos && oppKingPos.x === x) {
            let hasPieceBetween = false;
            const minY = Math.min(y, oppKingPos.y) + 1;
            const maxY = Math.max(y, oppKingPos.y);
            
            for (let i = minY; i < maxY; i++) {
                if (boardState[i][x]) {
                    hasPieceBetween = true;
                    break;
                }
            }
            
            // 如果中间无子，则红王可以飞过去吃黑王
            if (!hasPieceBetween) {
                moves.push(oppKingPos);
            }
        }
        return moves;
    }

    function getAdvisorMoves(x, y, color) { /* ... (逻辑不变) ... */
        let moves = [];
        const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
        const palace = { xMin: 3, xMax: 5, yMin: 7, yMax: 9 };
        directions.forEach(([dx, dy]) => {
            const newX = x + dx, newY = y + dy;
            if (newX >= palace.xMin && newX <= palace.xMax && newY >= palace.yMin && newY <= palace.yMax) {
                if (canMoveTo(newX, newY, color)) {
                    moves.push({ x: newX, y: newY });
                }
            }
        });
        return moves;
    }

    function getElephantMoves(x, y, color) { 
        let moves = [];
        const directions = [[2, 2], [2, -2], [-2, 2], [-2, -2]];
        directions.forEach(([dx, dy]) => {
            const newX = x + dx, newY = y + dy;
            const eyeX = x + dx / 2, eyeY = y + dy / 2;
            // 红象不能过河，新规则中河界在 y=3 和 y=4，红方区域从 y=5 开始
            if (canMoveTo(newX, newY, color) && newY >= RIVER_Y_MIN*0-2  + 2 && isEmpty(eyeX, eyeY)) { // y >= 5
                moves.push({ x: newX, y: newY });
            }
        });
        return moves;
    }

    function getRookMoves(x, y, color) { /* ... (逻辑不变) ... */
        let moves = [];
        const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        directions.forEach(([dx, dy]) => {
            for (let i = 1; ; i++) {
                const newX = x + i * dx, newY = y + i * dy;
                if (!isOnBoard(newX, newY) || !canMoveTo(newX, newY, color)) break; // 使用 canMoveTo 检查边界和禁区
                if (isEmpty(newX, newY)) {
                    moves.push({ x: newX, y: newY });
                } else {
                    if (isOpponent(newX, newY, color)) moves.push({ x: newX, y: newY });
                    break;
                }
            }
        });
        return moves;
    }

    function getRedKnightMoves(x, y, color) { /* ... (逻辑不变) ... */
        let moves = [];
        const possibleMoves = [[1, 2], [1, -2], [-1, 2], [-1, -2], [2, 1], [2, -1], [-2, 1], [-2, -1]];
        
        possibleMoves.forEach(([dx, dy]) => {
            const newX = x + dx, newY = y + dy;
            let blocked = false;
            let blockX, blockY;
            if (Math.abs(dx) === 2) { 
                blockX = x + dx / 2;
                blockY = y;
            } else {
                blockX = x;
                blockY = y + dy / 2;
            }

            if (!isEmpty(blockX, blockY)) blocked = true;

            if (!blocked && canMoveTo(newX, newY, color)) {
                moves.push({ x: newX, y: newY });
            }
        });
        return moves;
    }

    function getBlackKnightMoves(x, y, color) { /* ... (逻辑不变) ... */
        let moves = [];
        const directions = [[1, 2], [1, -2], [-1, 2], [-1, -2], [2, 1], [2, -1], [-2, 1], [-2, -1]];
        directions.forEach(([dx, dy]) => {
            const newX = x + dx, newY = y + dy;
            if (canMoveTo(newX, newY, color)) {
                moves.push({ x: newX, y: newY });
            }
        });
        return moves;
    }
    
    function getCannonMoves(x, y, color) { /* ... (逻辑不变) ... */
        let moves = [];
        const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        directions.forEach(([dx, dy]) => {
            let jumped = false;
            for (let i = 1; ; i++) {
                const newX = x + i * dx, newY = y + i * dy;
                if (!isOnBoard(newX, newY) || !canMoveTo(newX, newY, color)) { // 检查边界和禁区
                    if (!isOnBoard(newX, newY)) break; // 确保不会无限循环
                    // 如果因为禁区不能走，不应该影响炮台判断，但这里为简化逻辑，依然停止
                }
                
                if (!jumped) {
                    if (isEmpty(newX, newY)) {
                        if (canMoveTo(newX, newY, color)) moves.push({ x: newX, y: newY }); // 确保不在禁区
                    } else {
                        jumped = true;
                    }
                } else {
                    if (!isEmpty(newX, newY)) {
                        if (isOpponent(newX, newY, color) && canMoveTo(newX, newY, color)) {
                            moves.push({ x: newX, y: newY });
                        }
                        break;
                    }
                }
            }
        });
        return moves;
    }

    function getRedPawnMoves(x, y, color) { 
        let moves = [];
        const forwardY = y - 1;
        // 前进
        if (canMoveTo(x, forwardY, color)) moves.push({ x: x, y: forwardY });
        // 过河后 (y <= 4 是河界，y <= 2 是黑方自由区)
        // 根据您的定义，红兵跨过 y=5 才是过河，但现在 y=5 是红方第一行
        // 假定红兵过河线为 y=4（即进入河界）
        if (y <= RIVER_Y_MIN + 1) { // y <= 4 (红兵进入河界或黑方区域)
            if (canMoveTo(x - 1, y, color)) moves.push({ x: x - 1, y: y });
            if (canMoveTo(x + 1, y, color)) moves.push({ x: x + 1, y: y });
        }
        return moves;
    }

    // 黑方王 (b_k) 的移动逻辑 (添加王车易位)
    function getKingMoves(x, y, color) {
        let moves = [];
        const directions = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];
        
        // 1. 常规八向移动
        directions.forEach(([dx, dy]) => {
            const newX = x + dx, newY = y + dy;
            if (canMoveTo(newX, newY, color)) {
                moves.push({ x: newX, y: newY });
            }
        });
        
        // 2. 王车易位 (仅限黑方，且王没有移动过，且王当前不在将军状态)
        // 注意：当前代码中没有实现将军检查，这里只检查是否有棋子阻挡和是否移动过。
        if (color === 'black' && !hasKingMoved['black'] && x === 4 && y === 0) { // 假定黑王初始位置为 (4, 0)

            // **辅助函数：检查路径上是否被攻击（简易版，只检查空位和是否移动）**
            const isPathClear = (start, end) => {
                for (let i = start; i <= end; i++) {
                    if (boardState[y][i]) return false;
                }
                return true;
            }
            
            // **短易位 (王翼, O-O):**
            const shortRookX = 7;
            if (!hasRookMoved['b_r_short'] && boardState[0][shortRookX] === 'b_r') {
                // 路径检查：(5, 0) 和 (6, 0) 必须为空
                if (isEmpty(5, 0) && isEmpty(6, 0)) {
                    // 忽略攻击检查（需要复杂的isSquareAttacked函数），如果需要，请后续要求添加。
                    moves.push({ x: 6, y: 0, isCastling: 'short' });
                }
            }

            // **长易位 (后翼, O-O-O):**
            const longRookX = 0;
            if (!hasRookMoved['b_r_long'] && boardState[0][longRookX] === 'b_r') {
                // 路径检查：(1, 0), (2, 0) 和 (3, 0) 必须为空
                if (isEmpty(1, 0) && isEmpty(2, 0) && isEmpty(3, 0)) {
                    // 忽略攻击检查（需要复杂的isSquareAttacked函数），如果需要，请后续要求添加。
                    moves.push({ x: 2, y: 0, isCastling: 'long' });
                }
            }
        }

        return moves;
    }

    function getQueenMoves(x, y, color) { 
        return getRookMoves(x, y, color).concat(getBishopMoves(x, y, color));
    }
    
    function getBishopMoves(x, y, color) { /* ... (逻辑不变) ... */
        let moves = [];
        const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
        directions.forEach(([dx, dy]) => {
            for (let i = 1; ; i++) {
                const newX = x + i * dx, newY = y + i * dy;
                if (!isOnBoard(newX, newY) || !canMoveTo(newX, newY, color)) break;
                if (isEmpty(newX, newY)) {
                    moves.push({ x: newX, y: newY });
                } else {
                    if (isOpponent(newX, newY, color)) moves.push({ x: newX, y: newY });
                    break;
                }
            }
        });
        return moves;
    }

    function getBlackPawnMoves(x, y, color) { /* ... (逻辑不变) ... */
        let moves = [];
        const forwardY = y + 1;
        
        if (canMoveTo(x, forwardY, color) && isEmpty(x, forwardY)) {
            moves.push({ x: x, y: forwardY });
            if (y === 1 && isEmpty(x, y + 2) && canMoveTo(x, y + 2, color)) { // 首次移动
                moves.push({ x: x, y: y + 2 });
            }
        }
        
        const captureMoves = [[x - 1, forwardY], [x + 1, forwardY]];
        captureMoves.forEach(([newX, newY]) => {
            if (isOnBoard(newX, newY) && isOpponent(newX, newY, color) && canMoveTo(newX, newY, color)) {
                moves.push({ x: newX, y: newY });
            }
        });
        return moves;
    }

    // ## 主移动逻辑分发 (保持与 V3 一致) ##
    function getValidMoves(pieceId, x, y) {
        const pieceType = pieceId.substring(2);
        const color = PIECES[pieceId].color;

        switch (pieceType) {
            case 'g': return getGeneralMoves(x, y, color);
            case 'a': return getAdvisorMoves(x, y, color);
            case 'e': return getElephantMoves(x, y, color);
            case 'r': return getRookMoves(x, y, color);
            case 'h': return getRedKnightMoves(x, y, color);
            case 'c': return getCannonMoves(x, y, color);
            case 'p': return color === 'red' ? getRedPawnMoves(x, y, color) : getBlackPawnMoves(x, y, color);
            case 'k': return getKingMoves(x, y, color);
            case 'q': return getQueenMoves(x, y, color);
            case 'b': return getBishopMoves(x, y, color);
            case 'n': return getBlackKnightMoves(x, y, color);
            default: return [];
        }
    }

    // --- 4. 游戏流程控制 ---
    function initGame() {
        boardState = Array(ROWS).fill(null).map(() => Array(COLS).fill(null));
        
        // 黑方 (国际象棋, 上半 y=0, 1, 2)
        // 第一行 (y=0): 车马象后王象马车 + 空
        boardState[0] = ['b_r', 'b_n', 'b_b', 'b_q', 'b_k', 'b_b', 'b_n', 'b_r', null]; 
        // 第二行 (y=1): 兵
        boardState[1] = Array(8).fill('b_p').concat(null); 
        // y=2 行空着

        // 红方 (中国象棋, 下半 y=5, 6, 7, 8)
        // 第八行 (y=8): 车马相仕帅仕相马车
        boardState[8] = ['r_r', 'r_h', 'r_e', 'r_a', 'r_g', 'r_a', 'r_e', 'r_h', 'r_r'];
        // 第六行 (y=6): 炮
        boardState[6] = [null, 'r_c', null, null, null, null, null, 'r_c', null];
        // 第五行 (y=5): 兵
        boardState[5] = ['r_p', null, 'r_p', null, 'r_p', null, 'r_p', null, 'r_p'];

        // ... (其他变量重置和函数调用保持不变)
        currentPlayer = 'black';
        selectedPiece = null;
        validMoves = [];
        gameStatus = 'ongoing';
        
        // 重置王车易位状态
        hasKingMoved = { 'black': false, 'red': false };
        hasRookMoved = {
            'b_r_long': false,
            'b_r_short': false,
        };
        
        updateInfoPanel();
        drawBoard();
        drawPiecesAndHighlights();
    }

    function switchPlayer() {
        currentPlayer = (currentPlayer === 'red') ? 'black' : 'red';
        updateInfoPanel();
    }

    function handleBoardClick(event) {
        if (gameStatus !== 'ongoing') return;

        const rect = piecesCanvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;

        const x = Math.round((mouseX - PADDING) / SQUARE_SIZE);
        const y = Math.round((mouseY - PADDING) / SQUARE_SIZE);

        if (!isOnBoard(x, y)) {
            selectedPiece = null;
            validMoves = [];
            drawPiecesAndHighlights();
            return;
        }

        if (selectedPiece) {
            const move = validMoves.find(m => m.x === x && m.y === y);
            
            if (move) {
                const targetPieceId = getPiece(x, y);
                
                // 播放音效
                if (targetPieceId) {
                    captureSound.play();
                } else {
                    moveSound.play();
                }

                if (targetPieceId === 'b_k') {
                    endGame('红方');
                } else if (targetPieceId === 'r_g') {
                    endGame('黑方');
                }

                boardState[y][x] = selectedPiece.pieceId;
                boardState[selectedPiece.y][selectedPiece.x] = null;
                
                // --- 执行王车易位 (新增) ---
                if (move.isCastling) {
                    const rookY = selectedPiece.y; // 应该总是 0
                    let oldRookX, newRookX;

                    if (move.isCastling === 'short') {
                        oldRookX = 7;
                        newRookX = 5;
                    } else { // long
                        oldRookX = 0;
                        newRookX = 3;
                    }
                    
                    // 移动车
                    boardState[rookY][newRookX] = boardState[rookY][oldRookX];
                    boardState[rookY][oldRookX] = null;

                    // 移动王（王移动两格）
                    boardState[y][x] = selectedPiece.pieceId;
                    boardState[selectedPiece.y][selectedPiece.x] = null;

                    // 标记王和车已移动
                    hasKingMoved['black'] = true;
                    if (move.isCastling === 'short') {
                        hasRookMoved['b_r_short'] = true;
                    } else {
                        hasRookMoved['b_r_long'] = true;
                    }
                } 
                // --- 常规移动 ---
                else { 
                    // 移动棋子
                    boardState[y][x] = selectedPiece.pieceId;
                    boardState[selectedPiece.y][selectedPiece.x] = null;
                    
                    // 追踪王车移动状态 (在第 2 步添加的代码)
                    if (selectedPiece.pieceId === 'b_k') {
                        hasKingMoved['black'] = true;
                    } else if (selectedPiece.pieceId === 'b_r') {
                        if (selectedPiece.x === 0 && selectedPiece.y === 0) {
                            hasRookMoved['b_r_long'] = true;
                        } else if (selectedPiece.x === 7 && selectedPiece.y === 0) {
                            hasRookMoved['b_r_short'] = true;
                        }
                    }
                }
                
                // 黑兵升变
                if (selectedPiece.pieceId === 'b_p' && y === ROWS - 1) {
                    // 弹出选择框，让用户选择升变的棋子：Q (后), R (车), B (象), N (马)
                    let newPieceId;
                    let validChoices = ['Q', 'R', 'B', 'N'];
                    
                    while (!newPieceId) {
                        const choice = prompt("黑兵升变：请输入 Q (后), R (车), B (象) 或 N (马)").toUpperCase();
                        
                        if (validChoices.includes(choice)) {
                            switch(choice) {
                                case 'Q': newPieceId = 'b_q'; break;
                                case 'R': newPieceId = 'b_r'; break;
                                case 'B': newPieceId = 'b_b'; break;
                                case 'N': newPieceId = 'b_n'; break;
                            }
                        } else {
                            alert("输入无效，请重新选择。");
                        }
                    }
                    boardState[y][x] = newPieceId;
                }

                selectedPiece = null;
                validMoves = [];
                switchPlayer();
            } else {
                if (selectedPiece.x === x && selectedPiece.y === y) {
                    selectedPiece = null;
                    validMoves = [];
                }
            }
        }
        
        const clickedPieceId = getPiece(x, y);
        if (clickedPieceId && PIECES[clickedPieceId].color === currentPlayer) {
            selectedPiece = { pieceId: clickedPieceId, x: x, y: y };
            validMoves = getValidMoves(clickedPieceId, x, y);
        }
        
        drawPiecesAndHighlights();
    }
    
    function updateInfoPanel() {
        const turnSpan = document.getElementById('current-turn');
        if (currentPlayer === 'red') {
            turnSpan.textContent = '红方';
            turnSpan.className = 'red';
        } else {
            turnSpan.textContent = '黑方';
            turnSpan.className = 'black';
        }
        
        const statusSpan = document.getElementById('game-status');
        if (gameStatus === 'ongoing') {
            statusSpan.textContent = '游戏中';
            statusSpan.style.color = '#333';
        } else {
            statusSpan.textContent = `游戏结束: ${gameStatus} 胜利!`;
            statusSpan.style.color = gameStatus === '红方' ? '#c00' : '#000';
        }
    }
    
    function endGame(winner) {
        gameStatus = winner;
        updateInfoPanel();
    }

    // --- 5. 事件监听与启动 ---
    piecesCanvas.addEventListener('click', handleBoardClick);
    document.getElementById('reset-button').addEventListener('click', initGame);

    initGame();
</script>

</body>
</html>